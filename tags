!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACK	net_util.h	21;"	d
ARRAY_SIZE	http.c	41;"	d	file:
BIT_AT	http.c	45;"	d	file:
CALLBACK_DATA	http.c	104;"	d	file:
CALLBACK_DATA_	http.c	84;"	d	file:
CALLBACK_DATA_NOADVANCE	http.c	108;"	d	file:
CALLBACK_NOTIFY	http.c	78;"	d	file:
CALLBACK_NOTIFY_	http.c	61;"	d	file:
CALLBACK_NOTIFY_NOADVANCE	http.c	81;"	d	file:
CHUNK	http_parse.h	9;"	d
CHUNKED	http.c	125;"	d	file:
CLOSE	http.c	127;"	d	file:
CONNECTION	http.c	121;"	d	file:
CONTENT_LENGTH	http.c	122;"	d	file:
CONTYPE_LENGTH	http_parse.h	18;"	d
CR	http.c	356;"	d	file:
CURRENT_LINE	http_parse.h	16;"	d
DIRECT	data_send.h	18;"	d
DeleteNode	link.c	/^int DeleteNode(Node *node, long ack_seq)$/;"	f	signature:(Node *node, long ack_seq)
DeleteNode	link.h	/^int DeleteNode(Node *, long );/;"	p	signature:(Node *, long )
ELEM_AT	http.c	51;"	d	file:
FALSE	link.h	28;"	d
FALSE	net_util.h	10;"	d
FILTER	data_send.h	19;"	d
FIRSTSHARK	net_util.h	18;"	d
F_CHUNKED	http.h	/^  { F_CHUNKED               = 1 << 0$/;"	e	enum:flags
F_CONNECTION_CLOSE	http.h	/^  , F_CONNECTION_CLOSE      = 1 << 2$/;"	e	enum:flags
F_CONNECTION_KEEP_ALIVE	http.h	/^  , F_CONNECTION_KEEP_ALIVE = 1 << 1$/;"	e	enum:flags
F_SKIPBODY	http.h	/^  , F_SKIPBODY              = 1 << 5$/;"	e	enum:flags
F_TRAILING	http.h	/^  , F_TRAILING              = 1 << 3$/;"	e	enum:flags
F_UPGRADE	http.h	/^  , F_UPGRADE               = 1 << 4$/;"	e	enum:flags
FreeLink	link.c	/^void FreeLink(Node * head)  $/;"	f	signature:(Node * head)
FreeLink	link.h	/^void FreeLink(Node * );$/;"	p	signature:(Node * )
GET	net_util.h	22;"	d
HTTP_BOTH	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_ERRNO_GEN	http.h	181;"	d
HTTP_ERRNO_GEN	http.h	185;"	d
HTTP_ERRNO_MAP	http.h	/^  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)$/;"	e	enum:http_errno
HTTP_ERRNO_MAP	http.h	138;"	d
HTTP_MAX_HEADER_SIZE	http.h	54;"	d
HTTP_METHOD_MAP	http.h	/^  HTTP_METHOD_MAP(XX)$/;"	e	enum:http_method
HTTP_METHOD_MAP	http.h	79;"	d
HTTP_PARSER_ERRNO	http.h	189;"	d
HTTP_PARSER_STRICT	http.h	50;"	d
HTTP_PARSER_VERSION_MAJOR	http.h	27;"	d
HTTP_PARSER_VERSION_MINOR	http.h	28;"	d
HTTP_REQUEST	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_RESPONSE	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_STRERROR_GEN	http.c	402;"	d	file:
HTTP_STRERROR_GEN	http.c	409;"	d	file:
IPHL	data_send.h	14;"	d
IPHL	net_util.h	28;"	d
IS_ALPHA	http.c	359;"	d	file:
IS_ALPHANUM	http.c	361;"	d	file:
IS_HEX	http.c	362;"	d	file:
IS_HOST_CHAR	http.c	373;"	d	file:
IS_HOST_CHAR	http.c	378;"	d	file:
IS_MARK	http.c	363;"	d	file:
IS_NUM	http.c	360;"	d	file:
IS_URL_CHAR	http.c	372;"	d	file:
IS_URL_CHAR	http.c	376;"	d	file:
IS_USERINFO_CHAR	http.c	366;"	d	file:
InsertNode	link.c	/^int InsertNode(Node * current, struct iphdr *this_iphdr, struct tcphdr *this_tcphdr, char * payload, int datalen) $/;"	f	signature:(Node * current, struct iphdr *this_iphdr, struct tcphdr *this_tcphdr, char * payload, int datalen)
InsertNode	link.h	/^int InsertNode(Node *, struct iphdr *, struct tcphdr *, char *, int);$/;"	p	signature:(Node *, struct iphdr *, struct tcphdr *, char *, int)
KEEP_ALIVE	http.c	126;"	d	file:
LF	http.c	357;"	d	file:
LOWER	http.c	358;"	d	file:
MARK	http.c	112;"	d	file:
MAX_HEADER_LINES	http_parse.h	17;"	d
MIN	http.c	37;"	d	file:
NEW_MESSAGE	http.c	394;"	d	file:
NEW_MESSAGE	http.c	397;"	d	file:
NODE	link.h	/^typedef struct NODE  $/;"	s
NODE::datalen	link.h	/^        int datalen;$/;"	m	struct:NODE	access:public
NODE::iphdr	link.h	/^        struct iphdr *iphdr;$/;"	m	struct:NODE	typeref:struct:NODE::iphdr	access:public
NODE::next	link.h	/^        struct NODE *next;  $/;"	m	struct:NODE	typeref:struct:NODE::NODE	access:public
NODE::payload	link.h	/^        char * payload;$/;"	m	struct:NODE	access:public
NODE::tcphdr	link.h	/^        struct tcphdr *tcphdr;$/;"	m	struct:NODE	typeref:struct:NODE::tcphdr	access:public
Node	link.h	/^}Node; $/;"	t	typeref:struct:NODE
PARSING_HEADER	http.c	312;"	d	file:
POST	net_util.h	23;"	d
PROXY_CONNECTION	http.c	120;"	d	file:
PSEUDO_SIZE	data_send.h	10;"	d
PrintData	trafficMonitor.c	/^void PrintData (const u_char * data , int Size)$/;"	f	signature:(const u_char * data , int Size)
SECONDSHARK	net_util.h	19;"	d
SEND_DIRECT	net_util.h	31;"	d
SEND_GET	net_util.h	32;"	d
SEND_POST	net_util.h	33;"	d
SET_ERRNO	http.c	54;"	d	file:
STRICT_CHECK	http.c	387;"	d	file:
STRICT_CHECK	http.c	396;"	d	file:
T	http.c	193;"	d	file:
T	http.c	195;"	d	file:
T	http.c	233;"	d	file:
TCPHL	data_send.h	13;"	d
TCPHL	net_util.h	27;"	d
THIRDSHARK	net_util.h	20;"	d
TOKEN	http.c	371;"	d	file:
TOKEN	http.c	375;"	d	file:
TRANSFER_ENCODING	http.c	123;"	d	file:
TRUE	link.h	32;"	d
TRUE	net_util.h	14;"	d
UF_FRAGMENT	http.h	/^  , UF_FRAGMENT         = 5$/;"	e	enum:http_parser_url_fields
UF_HOST	http.h	/^  , UF_HOST             = 1$/;"	e	enum:http_parser_url_fields
UF_MAX	http.h	/^  , UF_MAX              = 7$/;"	e	enum:http_parser_url_fields
UF_PATH	http.h	/^  , UF_PATH             = 3$/;"	e	enum:http_parser_url_fields
UF_PORT	http.h	/^  , UF_PORT             = 2$/;"	e	enum:http_parser_url_fields
UF_QUERY	http.h	/^  , UF_QUERY            = 4$/;"	e	enum:http_parser_url_fields
UF_SCHEMA	http.h	/^  { UF_SCHEMA           = 0$/;"	e	enum:http_parser_url_fields
UF_USERINFO	http.h	/^  , UF_USERINFO         = 6$/;"	e	enum:http_parser_url_fields
ULLONG_MAX	http.c	33;"	d	file:
UPGRADE	http.c	124;"	d	file:
XX	http.c	132;"	d	file:
XX	http.c	134;"	d	file:
XX	http.h	114;"	d
XX	http.h	116;"	d
__anon2::description	http.c	/^  const char *description;$/;"	m	struct:__anon2	file:	access:public
__anon2::name	http.c	/^  const char *name;$/;"	m	struct:__anon2	file:	access:public
_filter	net_util.c	/^int _filter(char *data)$/;"	f	signature:(char *data)
_is_forbiden	net_util.c	/^int _is_forbiden(char *data)$/;"	f	signature:(char *data)
_recal_cksum	data_send.c	/^int _recal_cksum(char *data)$/;"	f	signature:(char *data)
_replace	net_util.c	/^int _replace(char *data)$/;"	f	signature:(char *data)
_send_data	data_send.c	/^int _send_data(char *data, int flag)$/;"	f	signature:(char *data, int flag)
_string_process_h	stringProcess.h	2;"	d
_url_len	net_util.c	/^int  _url_len(char *payload)$/;"	f	signature:(char *payload)
adres	html_recon.c	/^adres (struct tuple4 addr)$/;"	f	signature:(struct tuple4 addr)
charset	http_parse.h	/^char charset[10];$/;"	v
charset_parse	http_parse.c	/^void charset_parse(char *contype_value, char *contype, char *str)$/;"	f	signature:(char *contype_value, char *contype, char *str)
charset_parse	http_parse.h	/^void charset_parse(char *, char *, char* );$/;"	p	signature:(char *, char *, char* )
content_filter	net_util.c	/^int content_filter(struct iphdr *iph)$/;"	f	signature:(struct iphdr *iph)
content_filter	net_util.h	/^int content_filter(struct iphdr *iph);$/;"	p	signature:(struct iphdr *iph)
content_length	http.h	/^  uint64_t content_length; \/* # bytes in body (0 if no Content-Length header) *\/$/;"	m	struct:http_parser	access:public
contype	http_parse.h	/^char contype[30];$/;"	v
createNode	link.c	/^Node * createNode()  $/;"	f
createNode	link.h	/^Node * createNode();$/;"	p	signature:()
daddr	data_send.h	/^    u_long saddr, daddr;\/* source and dest address *\/$/;"	m	struct:pseudo_hdr	access:public
data	html_recon.h	/^	char *data;$/;"	m	struct:html	access:public
data	http.h	/^  void *data; \/* A pointer to get hook to the "connection" or "socket" object *\/$/;"	m	struct:http_parser	access:public
datalen	link.h	/^        int datalen;$/;"	m	struct:NODE	access:public
decompress	http_parse.c	/^int decompress(char *compressdata, char *uncompressdata, int size)$/;"	f	signature:(char *compressdata, char *uncompressdata, int size)
description	http.c	/^  const char *description;$/;"	m	struct:__anon2	file:	access:public
dest	http_parse.c	/^FILE *dest;$/;"	v
deviceChose	trafficMonitor.c	/^void deviceChose(char* devname)$/;"	f	signature:(char* devname)
fd	data_send.h	/^static int fd;$/;"	v
field	http_parse.h	/^  char *field;$/;"	m	struct:line	access:public
field_data	http.h	/^  } field_data[UF_MAX];$/;"	m	struct:http_parser_url	typeref:struct:http_parser_url::__anon1	access:public
field_set	http.h	/^  uint16_t field_set;           \/* Bitmask of (1 << UF_*) values *\/$/;"	m	struct:http_parser_url	access:public
fileRead	http_parse.c	/^char* fileRead(char *filename, long* file_length)$/;"	f	signature:(char *filename, long* file_length)
fileRead	http_parse.h	/^char* fileRead(char *filename, long* file_length);$/;"	p	signature:(char *filename, long* file_length)
flags	http.h	/^  unsigned char flags : 6;    \/* F_* values from 'flags' enum; semi-public *\/$/;"	m	struct:http_parser	access:public
flags	http.h	/^enum flags$/;"	g
h_C	http.c	/^  , h_C$/;"	e	enum:header_states	file:
h_CO	http.c	/^  , h_CO$/;"	e	enum:header_states	file:
h_CON	http.c	/^  , h_CON$/;"	e	enum:header_states	file:
h_connection	http.c	/^  , h_connection$/;"	e	enum:header_states	file:
h_connection_close	http.c	/^  , h_connection_close$/;"	e	enum:header_states	file:
h_connection_keep_alive	http.c	/^  , h_connection_keep_alive$/;"	e	enum:header_states	file:
h_content_length	http.c	/^  , h_content_length$/;"	e	enum:header_states	file:
h_general	http.c	/^  { h_general = 0$/;"	e	enum:header_states	file:
h_matching_connection	http.c	/^  , h_matching_connection$/;"	e	enum:header_states	file:
h_matching_connection_close	http.c	/^  , h_matching_connection_close$/;"	e	enum:header_states	file:
h_matching_connection_keep_alive	http.c	/^  , h_matching_connection_keep_alive$/;"	e	enum:header_states	file:
h_matching_content_length	http.c	/^  , h_matching_content_length$/;"	e	enum:header_states	file:
h_matching_proxy_connection	http.c	/^  , h_matching_proxy_connection$/;"	e	enum:header_states	file:
h_matching_transfer_encoding	http.c	/^  , h_matching_transfer_encoding$/;"	e	enum:header_states	file:
h_matching_transfer_encoding_chunked	http.c	/^  , h_matching_transfer_encoding_chunked$/;"	e	enum:header_states	file:
h_matching_upgrade	http.c	/^  , h_matching_upgrade$/;"	e	enum:header_states	file:
h_transfer_encoding	http.c	/^  , h_transfer_encoding$/;"	e	enum:header_states	file:
h_transfer_encoding_chunked	http.c	/^  , h_transfer_encoding_chunked$/;"	e	enum:header_states	file:
h_upgrade	http.c	/^  , h_upgrade$/;"	e	enum:header_states	file:
header	http_parse.h	/^static struct line header[MAX_HEADER_LINES];$/;"	v	typeref:struct:line
header_state	http.h	/^  unsigned char header_state; \/* enum header_state from http_parser.c *\/$/;"	m	struct:http_parser	access:public
header_states	http.c	/^enum header_states$/;"	g	file:
html	html_recon.h	/^struct html$/;"	s
html::data	html_recon.h	/^	char *data;$/;"	m	struct:html	access:public
html::length	html_recon.h	/^	int length;$/;"	m	struct:html	access:public
http_body_is_final	http.c	/^http_body_is_final(const struct http_parser *parser) {$/;"	f	signature:(const struct http_parser *parser)
http_body_is_final	http.h	/^int http_body_is_final(const http_parser *parser);$/;"	p	signature:(const http_parser *parser)
http_cb	http.h	/^typedef int (*http_cb) (http_parser*);$/;"	t
http_data_cb	http.h	/^typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);$/;"	t
http_errno	http.h	/^  unsigned char http_errno : 7;$/;"	m	struct:http_parser	access:public
http_errno	http.h	/^enum http_errno {$/;"	g
http_errno_description	http.c	/^http_errno_description(enum http_errno err) {$/;"	f	signature:(enum http_errno err)
http_errno_description	http.h	/^const char *http_errno_description(enum http_errno err);$/;"	p	signature:(enum http_errno err)
http_errno_name	http.c	/^http_errno_name(enum http_errno err) {$/;"	f	signature:(enum http_errno err)
http_errno_name	http.h	/^const char *http_errno_name(enum http_errno err);$/;"	p	signature:(enum http_errno err)
http_host_state	http.c	/^enum http_host_state$/;"	g	file:
http_major	http.h	/^  unsigned short http_major;$/;"	m	struct:http_parser	access:public
http_message_needs_eof	http.c	/^http_message_needs_eof (const http_parser *parser)$/;"	f	signature:(const http_parser *parser)
http_message_needs_eof	http.c	/^int http_message_needs_eof(const http_parser *parser);$/;"	p	file:	signature:(const http_parser *parser)
http_method	http.h	/^enum http_method$/;"	g
http_method_str	http.c	/^http_method_str (enum http_method m)$/;"	f	signature:(enum http_method m)
http_method_str	http.h	/^const char *http_method_str(enum http_method m);$/;"	p	signature:(enum http_method m)
http_minor	http.h	/^  unsigned short http_minor;$/;"	m	struct:http_parser	access:public
http_parse_host	http.c	/^http_parse_host(const char * buf, struct http_parser_url *u, int found_at) {$/;"	f	file:	signature:(const char * buf, struct http_parser_url *u, int found_at)
http_parse_host_char	http.c	/^http_parse_host_char(enum http_host_state s, const char ch) {$/;"	f	file:	signature:(enum http_host_state s, const char ch)
http_parser	http.h	/^struct http_parser {$/;"	s
http_parser	http.h	/^typedef struct http_parser http_parser;$/;"	t	typeref:struct:http_parser
http_parser::content_length	http.h	/^  uint64_t content_length; \/* # bytes in body (0 if no Content-Length header) *\/$/;"	m	struct:http_parser	access:public
http_parser::data	http.h	/^  void *data; \/* A pointer to get hook to the "connection" or "socket" object *\/$/;"	m	struct:http_parser	access:public
http_parser::flags	http.h	/^  unsigned char flags : 6;    \/* F_* values from 'flags' enum; semi-public *\/$/;"	m	struct:http_parser	access:public
http_parser::header_state	http.h	/^  unsigned char header_state; \/* enum header_state from http_parser.c *\/$/;"	m	struct:http_parser	access:public
http_parser::http_errno	http.h	/^  unsigned char http_errno : 7;$/;"	m	struct:http_parser	access:public
http_parser::http_major	http.h	/^  unsigned short http_major;$/;"	m	struct:http_parser	access:public
http_parser::http_minor	http.h	/^  unsigned short http_minor;$/;"	m	struct:http_parser	access:public
http_parser::index	http.h	/^  unsigned char index;        \/* index into current matcher *\/$/;"	m	struct:http_parser	access:public
http_parser::method	http.h	/^  unsigned char method;       \/* requests only *\/$/;"	m	struct:http_parser	access:public
http_parser::nread	http.h	/^  uint32_t nread;          \/* # bytes read in various scenarios *\/$/;"	m	struct:http_parser	access:public
http_parser::state	http.h	/^  unsigned char state;        \/* enum state from http_parser.c *\/$/;"	m	struct:http_parser	access:public
http_parser::status_code	http.h	/^  unsigned short status_code; \/* responses only *\/$/;"	m	struct:http_parser	access:public
http_parser::type	http.h	/^  unsigned char type : 2;     \/* enum http_parser_type *\/$/;"	m	struct:http_parser	access:public
http_parser::upgrade	http.h	/^  unsigned char upgrade : 1;$/;"	m	struct:http_parser	access:public
http_parser_execute	http.c	/^size_t http_parser_execute (http_parser *parser,$/;"	f	signature:(http_parser *parser, const http_parser_settings *settings, const char *data, size_t len)
http_parser_execute	http.h	/^size_t http_parser_execute(http_parser *parser,$/;"	p	signature:(http_parser *parser, const http_parser_settings *settings, const char *data, size_t len)
http_parser_h	http.h	22;"	d
http_parser_init	http.c	/^http_parser_init (http_parser *parser, enum http_parser_type t)$/;"	f	signature:(http_parser *parser, enum http_parser_type t)
http_parser_init	http.h	/^void http_parser_init(http_parser *parser, enum http_parser_type type);$/;"	p	signature:(http_parser *parser, enum http_parser_type type)
http_parser_parse_url	http.c	/^http_parser_parse_url(const char *buf, size_t buflen, int is_connect,$/;"	f	signature:(const char *buf, size_t buflen, int is_connect, struct http_parser_url *u)
http_parser_parse_url	http.h	/^int http_parser_parse_url(const char *buf, size_t buflen,$/;"	p	signature:(const char *buf, size_t buflen, int is_connect, struct http_parser_url *u)
http_parser_pause	http.c	/^http_parser_pause(http_parser *parser, int paused) {$/;"	f	signature:(http_parser *parser, int paused)
http_parser_pause	http.h	/^void http_parser_pause(http_parser *parser, int paused);$/;"	p	signature:(http_parser *parser, int paused)
http_parser_settings	http.h	/^struct http_parser_settings {$/;"	s
http_parser_settings	http.h	/^typedef struct http_parser_settings http_parser_settings;$/;"	t	typeref:struct:http_parser_settings
http_parser_settings::on_body	http.h	/^  http_data_cb on_body;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_header_field	http.h	/^  http_data_cb on_header_field;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_header_value	http.h	/^  http_data_cb on_header_value;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_headers_complete	http.h	/^  http_cb      on_headers_complete;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_message_begin	http.h	/^  http_cb      on_message_begin;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_message_complete	http.h	/^  http_cb      on_message_complete;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_status_complete	http.h	/^  http_cb      on_status_complete;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_url	http.h	/^  http_data_cb on_url;$/;"	m	struct:http_parser_settings	access:public
http_parser_type	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	g
http_parser_url	http.h	/^struct http_parser_url {$/;"	s
http_parser_url::__anon1::len	http.h	/^    uint16_t len;               \/* Length of run in buffer *\/$/;"	m	struct:http_parser_url::__anon1	access:public
http_parser_url::__anon1::off	http.h	/^    uint16_t off;               \/* Offset into buffer in which field starts *\/$/;"	m	struct:http_parser_url::__anon1	access:public
http_parser_url::field_data	http.h	/^  } field_data[UF_MAX];$/;"	m	struct:http_parser_url	typeref:struct:http_parser_url::__anon1	access:public
http_parser_url::field_set	http.h	/^  uint16_t field_set;           \/* Bitmask of (1 << UF_*) values *\/$/;"	m	struct:http_parser_url	access:public
http_parser_url::port	http.h	/^  uint16_t port;                \/* Converted UF_PORT string *\/$/;"	m	struct:http_parser_url	access:public
http_parser_url_fields	http.h	/^enum http_parser_url_fields$/;"	g
http_should_keep_alive	http.c	/^http_should_keep_alive (const http_parser *parser)$/;"	f	signature:(const http_parser *parser)
http_should_keep_alive	http.h	/^int http_should_keep_alive(const http_parser *parser);$/;"	p	signature:(const http_parser *parser)
http_strerror_tab	http.c	/^} http_strerror_tab[] = {$/;"	v	typeref:struct:__anon2	file:
in_cksum	data_send.c	/^ inline u_short in_cksum(u_short *addr, int len)$/;"	f	signature:(u_short *addr, int len)
index	http.h	/^  unsigned char index;        \/* index into current matcher *\/$/;"	m	struct:http_parser	access:public
int16_t	http.h	/^typedef __int16 int16_t;$/;"	t
int32_t	http.h	/^typedef __int32 int32_t;$/;"	t
int64_t	http.h	/^typedef __int64 int64_t;$/;"	t
int8_t	http.h	/^typedef __int8 int8_t;$/;"	t
int_ntoa	html_recon.h	4;"	d
iphdr	link.h	/^        struct iphdr *iphdr;$/;"	m	struct:NODE	typeref:struct:NODE::iphdr	access:public
isFromDest	net_util.c	/^int isFromDest(uint32_t net)$/;"	f	signature:(uint32_t net)
isFromDest	net_util.h	/^int isFromDest(uint32_t);$/;"	p	signature:(uint32_t)
isFromSrc	net_util.c	/^int isFromSrc(struct iphdr *iph, char *ip)$/;"	f	signature:(struct iphdr *iph, char *ip)
isFromSrc	net_util.h	/^int isFromSrc(struct iphdr *, char *);$/;"	p	signature:(struct iphdr *, char *)
isGzip	http_parse.h	/^static int isGzip = 0;$/;"	v
ishost	net_util.c	/^int ishost(struct iphdr *iph, char *hostname)$/;"	f	signature:(struct iphdr *iph, char *hostname)
ishost	net_util.h	/^int ishost(struct iphdr *iph, char *hostname);$/;"	p	signature:(struct iphdr *iph, char *hostname)
kmp_search	stringProcess.c	/^const char *kmp_search(const char *text, const char *pattern)$/;"	f	signature:(const char *text, const char *pattern)
kmp_search	stringProcess.h	/^const char *kmp_search(const char *text, const char *pattern);$/;"	p	signature:(const char *text, const char *pattern)
len	http.h	/^    uint16_t len;               \/* Length of run in buffer *\/$/;"	m	struct:http_parser_url::__anon1	access:public
length	html_recon.h	/^	int length;$/;"	m	struct:html	access:public
line	http_parse.h	/^struct line {$/;"	s
line::field	http_parse.h	/^  char *field;$/;"	m	struct:line	access:public
line::value	http_parse.h	/^  char *value;$/;"	m	struct:line	access:public
logfile	trafficMonitor.h	/^FILE *logfile;/;"	v
main	sniff.c	/^int main()$/;"	f
mbz	data_send.h	/^    u_char mbz, ptcl;	\/* zero and protocol *\/$/;"	m	struct:pseudo_hdr	access:public
method	http.h	/^  unsigned char method;       \/* requests only *\/$/;"	m	struct:http_parser	access:public
method_strings	http.c	/^static const char *method_strings[] =$/;"	v	file:
monitor	trafficMonitor.c	/^void monitor()$/;"	f
monitor	trafficMonitor.h	/^void monitor();$/;"	p	signature:()
name	http.c	/^  const char *name;$/;"	m	struct:__anon2	file:	access:public
next	link.h	/^        struct NODE *next;  $/;"	m	struct:NODE	typeref:struct:NODE::NODE	access:public
nlines	http_parse.h	/^static int nlines = 0;$/;"	v
normal_url_char	http.c	/^static const uint8_t normal_url_char[32] = {$/;"	v	file:
nread	http.h	/^  uint32_t nread;          \/* # bytes read in various scenarios *\/$/;"	m	struct:http_parser	access:public
off	http.h	/^    uint16_t off;               \/* Offset into buffer in which field starts *\/$/;"	m	struct:http_parser_url::__anon1	access:public
on_body	http.h	/^  http_data_cb on_body;$/;"	m	struct:http_parser_settings	access:public
on_body	http_parse.c	/^int on_body(http_parser* _, const char* at, size_t length) {$/;"	f	signature:(http_parser* _, const char* at, size_t length)
on_body	http_parse.h	/^int on_body(http_parser* _, const char* at, size_t length);$/;"	p	signature:(http_parser* _, const char* at, size_t length)
on_header_field	http.h	/^  http_data_cb on_header_field;$/;"	m	struct:http_parser_settings	access:public
on_header_field	http_parse.c	/^int on_header_field(http_parser* _, const char* at, size_t length) {$/;"	f	signature:(http_parser* _, const char* at, size_t length)
on_header_field	http_parse.h	/^int on_header_field(http_parser* _, const char* at, size_t length);$/;"	p	signature:(http_parser* _, const char* at, size_t length)
on_header_value	http.h	/^  http_data_cb on_header_value;$/;"	m	struct:http_parser_settings	access:public
on_header_value	http_parse.c	/^int on_header_value(http_parser* _, const char* at, size_t length) {$/;"	f	signature:(http_parser* _, const char* at, size_t length)
on_header_value	http_parse.h	/^int on_header_value(http_parser* _, const char* at, size_t length);$/;"	p	signature:(http_parser* _, const char* at, size_t length)
on_headers_complete	http.h	/^  http_cb      on_headers_complete;$/;"	m	struct:http_parser_settings	access:public
on_headers_complete	http_parse.c	/^int on_headers_complete(http_parser* _) {$/;"	f	signature:(http_parser* _)
on_headers_complete	http_parse.h	/^int on_headers_complete(http_parser* _);$/;"	p	signature:(http_parser* _)
on_message_begin	http.h	/^  http_cb      on_message_begin;$/;"	m	struct:http_parser_settings	access:public
on_message_begin	http_parse.c	/^int on_message_begin(http_parser* _) {$/;"	f	signature:(http_parser* _)
on_message_begin	http_parse.h	/^int on_message_begin(http_parser* _);$/;"	p	signature:(http_parser* _)
on_message_complete	http.h	/^  http_cb      on_message_complete;$/;"	m	struct:http_parser_settings	access:public
on_message_complete	http_parse.c	/^int on_message_complete(http_parser* _) {$/;"	f	signature:(http_parser* _)
on_message_complete	http_parse.h	/^int on_message_complete(http_parser* _);$/;"	p	signature:(http_parser* _)
on_status_complete	http.h	/^  http_cb      on_status_complete;$/;"	m	struct:http_parser_settings	access:public
on_url	http.h	/^  http_data_cb on_url;$/;"	m	struct:http_parser_settings	access:public
on_url	http_parse.c	/^int on_url(http_parser* _, const char* at, size_t length) {$/;"	f	signature:(http_parser* _, const char* at, size_t length)
on_url	http_parse.h	/^int on_url(http_parser* _, const char* at, size_t length);$/;"	p	signature:(http_parser* _, const char* at, size_t length)
optval	data_send.h	/^static int optval=1;/;"	v
parse_url_char	http.c	/^parse_url_char(enum state s, const char ch)$/;"	f	file:	signature:(enum state s, const char ch)
payload	link.h	/^        char * payload;$/;"	m	struct:NODE	access:public
port	http.h	/^  uint16_t port;                \/* Converted UF_PORT string *\/$/;"	m	struct:http_parser_url	access:public
print_ethernet_header	trafficMonitor.c	/^void print_ethernet_header(const u_char *Buffer, int Size)$/;"	f	signature:(const u_char *Buffer, int Size)
print_ip_header	trafficMonitor.c	/^void print_ip_header(const u_char * Buffer, int Size)$/;"	f	signature:(const u_char * Buffer, int Size)
print_tcp_packet	trafficMonitor.c	/^void print_tcp_packet(const u_char * Buffer, int Size)$/;"	f	signature:(const u_char * Buffer, int Size)
process_packet	trafficMonitor.c	/^void process_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *buffer)$/;"	f	signature:(u_char *args, const struct pcap_pkthdr *header, const u_char *buffer)
processhttp	http_parse.c	/^int processhttp(FILE *file, char* data, size_t http_length)$/;"	f	signature:(FILE *file, char* data, size_t http_length)
processhttp	http_parse.h	/^int processhttp(FILE *, char*, size_t);$/;"	p	signature:(FILE *, char*, size_t)
pseudo_hdr	data_send.h	/^struct pseudo_hdr { \/* See RFC 793 Pseudo Header *\/$/;"	s
pseudo_hdr::daddr	data_send.h	/^    u_long saddr, daddr;\/* source and dest address *\/$/;"	m	struct:pseudo_hdr	access:public
pseudo_hdr::mbz	data_send.h	/^    u_char mbz, ptcl;	\/* zero and protocol *\/$/;"	m	struct:pseudo_hdr	access:public
pseudo_hdr::ptcl	data_send.h	/^    u_char mbz, ptcl;	\/* zero and protocol *\/$/;"	m	struct:pseudo_hdr	access:public
pseudo_hdr::saddr	data_send.h	/^    u_long saddr, daddr;\/* source and dest address *\/$/;"	m	struct:pseudo_hdr	access:public
pseudo_hdr::tcpl	data_send.h	/^    u_short tcpl;	\/* tcp length *\/$/;"	m	struct:pseudo_hdr	access:public
ptcl	data_send.h	/^    u_char mbz, ptcl;	\/* zero and protocol *\/$/;"	m	struct:pseudo_hdr	access:public
s_body_identity	http.c	/^  , s_body_identity$/;"	e	enum:state	file:
s_body_identity_eof	http.c	/^  , s_body_identity_eof$/;"	e	enum:state	file:
s_chunk_data	http.c	/^  , s_chunk_data$/;"	e	enum:state	file:
s_chunk_data_almost_done	http.c	/^  , s_chunk_data_almost_done$/;"	e	enum:state	file:
s_chunk_data_done	http.c	/^  , s_chunk_data_done$/;"	e	enum:state	file:
s_chunk_parameters	http.c	/^  , s_chunk_parameters$/;"	e	enum:state	file:
s_chunk_size	http.c	/^  , s_chunk_size$/;"	e	enum:state	file:
s_chunk_size_almost_done	http.c	/^  , s_chunk_size_almost_done$/;"	e	enum:state	file:
s_chunk_size_start	http.c	/^  , s_chunk_size_start$/;"	e	enum:state	file:
s_dead	http.c	/^  { s_dead = 1 \/* important that this is > 0 *\/$/;"	e	enum:state	file:
s_header_almost_done	http.c	/^  , s_header_almost_done$/;"	e	enum:state	file:
s_header_field	http.c	/^  , s_header_field$/;"	e	enum:state	file:
s_header_field_start	http.c	/^  , s_header_field_start$/;"	e	enum:state	file:
s_header_value	http.c	/^  , s_header_value$/;"	e	enum:state	file:
s_header_value_lws	http.c	/^  , s_header_value_lws$/;"	e	enum:state	file:
s_header_value_start	http.c	/^  , s_header_value_start$/;"	e	enum:state	file:
s_headers_almost_done	http.c	/^  , s_headers_almost_done$/;"	e	enum:state	file:
s_headers_done	http.c	/^  , s_headers_done$/;"	e	enum:state	file:
s_http_host	http.c	/^  , s_http_host$/;"	e	enum:http_host_state	file:
s_http_host_dead	http.c	/^    s_http_host_dead = 1$/;"	e	enum:http_host_state	file:
s_http_host_port	http.c	/^  , s_http_host_port$/;"	e	enum:http_host_state	file:
s_http_host_port_start	http.c	/^  , s_http_host_port_start$/;"	e	enum:http_host_state	file:
s_http_host_start	http.c	/^  , s_http_host_start$/;"	e	enum:http_host_state	file:
s_http_host_v6	http.c	/^  , s_http_host_v6$/;"	e	enum:http_host_state	file:
s_http_host_v6_end	http.c	/^  , s_http_host_v6_end$/;"	e	enum:http_host_state	file:
s_http_host_v6_start	http.c	/^  , s_http_host_v6_start$/;"	e	enum:http_host_state	file:
s_http_userinfo	http.c	/^  , s_http_userinfo$/;"	e	enum:http_host_state	file:
s_http_userinfo_start	http.c	/^  , s_http_userinfo_start$/;"	e	enum:http_host_state	file:
s_message_done	http.c	/^  , s_message_done$/;"	e	enum:state	file:
s_req_first_http_major	http.c	/^  , s_req_first_http_major$/;"	e	enum:state	file:
s_req_first_http_minor	http.c	/^  , s_req_first_http_minor$/;"	e	enum:state	file:
s_req_fragment	http.c	/^  , s_req_fragment$/;"	e	enum:state	file:
s_req_fragment_start	http.c	/^  , s_req_fragment_start$/;"	e	enum:state	file:
s_req_http_H	http.c	/^  , s_req_http_H$/;"	e	enum:state	file:
s_req_http_HT	http.c	/^  , s_req_http_HT$/;"	e	enum:state	file:
s_req_http_HTT	http.c	/^  , s_req_http_HTT$/;"	e	enum:state	file:
s_req_http_HTTP	http.c	/^  , s_req_http_HTTP$/;"	e	enum:state	file:
s_req_http_major	http.c	/^  , s_req_http_major$/;"	e	enum:state	file:
s_req_http_minor	http.c	/^  , s_req_http_minor$/;"	e	enum:state	file:
s_req_http_start	http.c	/^  , s_req_http_start$/;"	e	enum:state	file:
s_req_line_almost_done	http.c	/^  , s_req_line_almost_done$/;"	e	enum:state	file:
s_req_method	http.c	/^  , s_req_method$/;"	e	enum:state	file:
s_req_path	http.c	/^  , s_req_path$/;"	e	enum:state	file:
s_req_query_string	http.c	/^  , s_req_query_string$/;"	e	enum:state	file:
s_req_query_string_start	http.c	/^  , s_req_query_string_start$/;"	e	enum:state	file:
s_req_schema	http.c	/^  , s_req_schema$/;"	e	enum:state	file:
s_req_schema_slash	http.c	/^  , s_req_schema_slash$/;"	e	enum:state	file:
s_req_schema_slash_slash	http.c	/^  , s_req_schema_slash_slash$/;"	e	enum:state	file:
s_req_server	http.c	/^  , s_req_server$/;"	e	enum:state	file:
s_req_server_start	http.c	/^  , s_req_server_start$/;"	e	enum:state	file:
s_req_server_with_at	http.c	/^  , s_req_server_with_at$/;"	e	enum:state	file:
s_req_spaces_before_url	http.c	/^  , s_req_spaces_before_url$/;"	e	enum:state	file:
s_res_H	http.c	/^  , s_res_H$/;"	e	enum:state	file:
s_res_HT	http.c	/^  , s_res_HT$/;"	e	enum:state	file:
s_res_HTT	http.c	/^  , s_res_HTT$/;"	e	enum:state	file:
s_res_HTTP	http.c	/^  , s_res_HTTP$/;"	e	enum:state	file:
s_res_first_http_major	http.c	/^  , s_res_first_http_major$/;"	e	enum:state	file:
s_res_first_http_minor	http.c	/^  , s_res_first_http_minor$/;"	e	enum:state	file:
s_res_first_status_code	http.c	/^  , s_res_first_status_code$/;"	e	enum:state	file:
s_res_http_major	http.c	/^  , s_res_http_major$/;"	e	enum:state	file:
s_res_http_minor	http.c	/^  , s_res_http_minor$/;"	e	enum:state	file:
s_res_line_almost_done	http.c	/^  , s_res_line_almost_done$/;"	e	enum:state	file:
s_res_or_resp_H	http.c	/^  , s_res_or_resp_H$/;"	e	enum:state	file:
s_res_status	http.c	/^  , s_res_status$/;"	e	enum:state	file:
s_res_status_code	http.c	/^  , s_res_status_code$/;"	e	enum:state	file:
s_start_req	http.c	/^  , s_start_req$/;"	e	enum:state	file:
s_start_req_or_res	http.c	/^  , s_start_req_or_res$/;"	e	enum:state	file:
s_start_res	http.c	/^  , s_start_res$/;"	e	enum:state	file:
sa	data_send.h	/^static struct sockaddr_in sa;$/;"	v	typeref:struct:sockaddr_in
saddr	data_send.h	/^    u_long saddr, daddr;\/* source and dest address *\/$/;"	m	struct:pseudo_hdr	access:public
send_data	net_util.c	/^int send_data(char *data, int flag)$/;"	f	signature:(char *data, int flag)
send_data	net_util.h	/^int send_data(char *, int);$/;"	p	signature:(char *, int)
send_direct	data_send.c	/^int send_direct(char *data)$/;"	f	signature:(char *data)
send_direct	data_send.h	/^int send_direct(char *);$/;"	p	signature:(char *)
send_filter	data_send.c	/^int send_filter(char *data)$/;"	f	signature:(char *data)
send_filter	data_send.h	/^int send_filter(char *);$/;"	p	signature:(char *)
send_rst	data_send.c	/^int send_rst(char *data)$/;"	f	signature:(char *data)
send_rst	data_send.h	/^int send_rst(char *);$/;"	p	signature:(char *)
seq	net_util.h	/^static long seq = 0;$/;"	v
start_state	http.c	383;"	d	file:
state	http.c	/^enum state$/;"	g	file:
state	http.h	/^  unsigned char state;        \/* enum state from http_parser.c *\/$/;"	m	struct:http_parser	access:public
status_code	http.h	/^  unsigned short status_code; \/* responses only *\/$/;"	m	struct:http_parser	access:public
store_html	html_recon.c	/^void store_html(char *data, int len)$/;"	f	signature:(char *data, int len)
store_html	html_recon.h	/^void store_html(char *, int);/;"	p	signature:(char *, int)
tcp_callback	html_recon.c	/^tcp_callback (struct tcp_stream *a_tcp, void ** this_time_not_needed)$/;"	f	signature:(struct tcp_stream *a_tcp, void ** this_time_not_needed)
tcp_type	net_util.c	/^int tcp_type(struct iphdr *iph)$/;"	f	signature:(struct iphdr *iph)
tcp_type	net_util.h	/^int tcp_type(struct iphdr *);$/;"	p	signature:(struct iphdr *)
tcphdr	link.h	/^        struct tcphdr *tcphdr;$/;"	m	struct:NODE	typeref:struct:NODE::tcphdr	access:public
tcpl	data_send.h	/^    u_short tcpl;	\/* tcp length *\/$/;"	m	struct:pseudo_hdr	access:public
tokens	http.c	/^static const char tokens[256] = {$/;"	v	file:
trim	stringProcess.c	/^void trim(char * str)$/;"	f	signature:(char * str)
type	http.h	/^  unsigned char type : 2;     \/* enum http_parser_type *\/$/;"	m	struct:http_parser	access:public
uint16_t	http.h	/^typedef unsigned __int16 uint16_t;$/;"	t
uint32_t	http.h	/^typedef unsigned __int32 uint32_t;$/;"	t
uint64_t	http.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint8_t	http.h	/^typedef unsigned __int8 uint8_t;$/;"	t
unhex	http.c	/^static const int8_t unhex[256] =$/;"	v	file:
upgrade	http.h	/^  unsigned char upgrade : 1;$/;"	m	struct:http_parser	access:public
value	http_parse.h	/^  char *value;$/;"	m	struct:line	access:public
zcompress	http_parse.c	/^int zcompress(char *compressdata, char *uncompressdata, int size)$/;"	f	signature:(char *compressdata, char *uncompressdata, int size)
